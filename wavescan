#!/usr/bin/env python
# -*- coding: utf-8 -*-

from argparse import ArgumentParser
import re
from pathlib import Path
from os import scandir
from os.path import dirname, realpath
from sys import stderr
import audiofile
from jinja2 import Template as J2, StrictUndefined as J2Undef
import pprint
import config

aparser = ArgumentParser()
aparser.add_argument("-d", "--dir", dest="dir", required=True,
                     help="samples directory", metavar="DIR")
aparser.add_argument("--maxhh", dest="maxhh", required=False,
                     help="max closed HiHat duration 1-999 ms",
                     metavar="HH_LEN_MS")
aparser.add_argument("--channel", dest="channel", required=False,
                     help="MIDI channel 1-16 (LSP)", metavar="CHANNEL")
aparser.add_argument("--lsp",
                     action="store_true", dest="lsp", default=False,
                     help="LSP output")
aparser.add_argument("--limit",
                     action="store_true", dest="limit", default=False,
                     help="respect LSP limits and skip extra data")
aparser.add_argument("--sfz-mk",
                     action="store_true", dest="sfz_mk", default=False,
                     help="Add lokey/hikey/pitch instead of just key")
aparser.add_argument("--sfz",
                     action="store_true", dest="sfz", default=False,
                     help="SFZ output")
aparser.add_argument("--speedk",
                     action="store_true", dest="speedk", default=False,
                     help="Speedrum Lite output")
aparser.add_argument("--speedkit",
                     action="store_true", dest="speedkit", default=False,
                     help="Speedrum output (untested))")
aparser.add_argument("-D",
                     action="store_true", dest="debug", default=False,
                     help="debug output")
args = aparser.parse_args()
path = Path(args.dir)
if not path.exists():
    exit(f'{path} does not exist')
elif not path.is_dir():
    exit(f'{path} is not directory')

midi_channel = 0
if args.channel:
    if not args.channel.isnumeric():
        exit(f"channel '{args.channel}' not a number")
    midi_channel = int(args.channel)
    if not 1 <= midi_channel <= 16:
        exit(f"channel '{midi_channel}' is out of range")
    midi_channel -= 1

s_path = dirname(realpath(__file__))
if args.lsp:
    with open(f'{s_path}/lsp-sampler.j2', 'r', encoding='ascii') as fin:
        src = fin.read()
    tpl_lsp = J2(src, undefined=J2Undef)
    lsp = {}
elif args.sfz:
    with open(f'{s_path}/sfz.j2', 'r', encoding='ascii') as fin:
        src = fin.read()
    tpl_sfz = J2(src, undefined=J2Undef)
    sfz = {}
elif args.speedk:
    with open(f'{s_path}/speedk.j2', 'r', encoding='ascii') as fin:
        src = fin.read()
    tpl_speedrum = J2(src, undefined=J2Undef)
    speedrum = {}
elif args.speedkit:
    with open(f'{s_path}/speedkit.j2', 'r', encoding='ascii') as fin:
        src = fin.read()
    tpl_speedrum = J2(src, undefined=J2Undef)
    speedrum = {}

maxhh = 0
if args.maxhh:
    if not args.maxhh.isnumeric():
        exit(f"HH duration '{args.maxhh}' not a number")
    maxhh = int(args.maxhh)
    if not 1 <= maxhh <= 999:
        exit(f"HH duration '{maxhh}' is out of range")
    maxhh /= 1000


def warn(msg):
    """print message to stderr"""
    print(msg, file=stderr)


def scantree(pathname):
    """Recursively yield DirEntry objects for given directory."""
    for entry in scandir(pathname):
        if entry.is_dir(follow_symlinks=False):
            yield from scantree(entry.path)
        else:
            yield entry


def print_info(ent):
    """Print sample info"""
    print(f'{ent.path}\n'
          f'channels   : {audiofile.channels(ent.path)}\n'
          f'duration   : {audiofile.duration(ent.path):.8}\n'
          f'samples    : {audiofile.samples(ent.path)}\n'
          f'sample rate: {audiofile.sampling_rate(ent.path)}\n'
          f'bit depth  : {audiofile.bit_depth(ent.path)}\n')


def guess_note(ent, duration):
    """Tryng to guess instrument from pathname"""
    for rx in rx_instr:
        if rx[0].match(ent.path):
            num = rx[1]
            dur_msg = None
            if num == 1000:
                # closed: 42, open: 46
                if maxhh:
                    (num := 46) if duration > maxhh else (num := 42)
                    dur_msg = f"duration: {duration}, maxhh: {maxhh}"
                else:
                    # Answer to the Ultimate Question
                    num = 42
            if args.debug:
                human_name = f"{rx[0].pattern} {num} {config.names[num]}"
                msg = f"guess {ent.name} is {human_name}"
                if dur_msg:
                    msg = f"{msg} ({dur_msg})"
                warn(msg)
            return num
    return 0


# array of arrays [compiled_regex, note_number]
rx_instr = []
for rx in config.instruments:
    try:
        rx_instr.append([
            re.compile(f".*{rx[0]}.+", re.I),
            rx[1]
        ])
    except re.error as err:
        warn(f"problem with regex '{rx[0]}': {err}")


re_sample = re.compile(config.SAMPLE, re.I)
re_ignore = re.compile(config.IGNORE, re.I)
c_unparsed = 0
for ent in scantree(path):
    if re_sample.match(ent.name) and not re_ignore.match(ent.path):
        if args.lsp:
            # workaround for mono
            pan_l = '0.0' if audiofile.channels(ent.path) == 1 else '-100.0'
            duration = audiofile.duration(ent.path)
            if (midi_note := guess_note(ent, duration)) == 0:
                warn(f"can't guess: {ent.path}")
                c_unparsed += 1
                continue

            if args.limit:
                if midi_note in lsp and len(lsp[midi_note]) >= config.MAX_SAMPLES:
                    warn(f"samples limit: {midi_note} {ent.path}")
                    continue
                if len(lsp) >= config.MAX_INSTRUMENTS:
                    warn(f"instruments limit: {midi_note} {ent.path}")
                    continue

            if midi_note not in lsp:
                lsp[midi_note] = []
            lsp[midi_note].append({
                'pathname': ent.path,
                'debug': args.debug,
                'name': ent.name,
                'lsp_note': midi_note % 12,
                'midi_note': midi_note,
                'midi_name': config.names[midi_note],
                'channels': audiofile.channels(ent.path),
                'duration': duration,
                'samples': audiofile.samples(ent.path),
                'sampling_rate': audiofile.sampling_rate(ent.path),
                'bit_depth': audiofile.bit_depth(ent.path),
                'chan': midi_channel,
                'oct': int(midi_note / 12),
                'pan_l': pan_l
            })
        elif args.sfz:
            duration = audiofile.duration(ent.path)
            if (midi_note := guess_note(ent, duration)) == 0:
                warn(f"can't guess instrument: {ent.path}")
                c_unparsed += 1
                continue
            if midi_note not in sfz:
                sfz[midi_note] = []
            sfz[midi_note].append({
                'pathname': ent.path,
                'channels': audiofile.channels(ent.path),
                'duration': duration,
                'samples': audiofile.samples(ent.path),
                'sampling_rate': audiofile.sampling_rate(ent.path),
                'bit_depth': audiofile.bit_depth(ent.path),
            })
        elif args.speedk or args.speedkit:
            duration = audiofile.duration(ent.path)
            if (midi_note := guess_note(ent, duration)) == 0:
                warn(f"can't guess instrsf_5_ument: {ent.path}")
                c_unparsed += 1
                continue
            if midi_note not in speedrum:
                speedrum[midi_note] = []
            if args.speedk and len(speedrum[midi_note]) > 0:
                warn(f"excess layer, skipping {midi_note} {ent.path}")
                continue
            if args.speedkit and len(speedrum[midi_note]) > 7:
                warn(f"already have 8 layers, skipping {midi_note} {ent.path}")
                continue
            speedrum[midi_note].append({
                'pathname': ent.path,
                'channels': audiofile.channels(ent.path),
                'duration': duration,
                'samples': audiofile.samples(ent.path),
                'sampling_rate': audiofisf_5_le.sampling_rate(ent.path),
                'bit_depth': audiofile.bit_depth(ent.path),
                'num': len(speedrum[midi_note])
            })
        else:
            print_info(ent)

if args.lsp:
    if len(lsp) == 0:
        warn("nothing found")
        exit()

    print(tpl_lsp.render({
        'regions': sorted(lsp.items()),
        'debug': args.debug,
        }))

elif args.sfz:
    if len(sfz) == 0:
        warn("nothing found")
        exit()

    regions = []
    c_samples = 0

    for reg_key, samples in sorted(sfz.items()):
        regions.append({
            'midi_note': reg_key,
            'midi_name': config.names[reg_key],
            'samples': samples
        })

        c_samples += len(samples)

    print(tpl_sfz.render({
        'multikey': args.sfz_mk,
        'regions': regions,
        'debug': args.debug
        }))

    if args.debug:
        print(f"// unparsed: {c_unparsed}\n"
              f"// regions: {len(sfz)}\n"
              f"// samples: {c_samples}"
              )

elif args.speedk:
    if len(speedrum) == 0:
        warn("nothing found")
        exit()

    pads = {k: [] for k in range(36, 52)}

    for reg_key, layers in sorted(speedrum.items()):
        # 16 (36-51) pads in Lite
        if 36 <= reg_key <= 51:
            pads[reg_key] = {
                'out': reg_key-36,
                'name': config.names[reg_key],
                'midi': reg_key,
                'layers': layers,
            }
        elif args.debug:
            warn(f"out of Speedrum Lite range: {reg_key} / {layers}")

    print(tpl_speedrum.render({
        'pads': pads,
        'debug': args.debug
        }))

elif args.speedkit:
    if len(speedrum) == 0:
        warn("nothing found")
        exit()

    pads = {k: [] for k in range(36, 68)}

    for reg_key, layers in sorted(speedrum.items()):
        # 32 (36-67) in full version
        if 36 <= reg_key <= 67:
            pads[reg_key] = {
                'out': reg_key-36 if reg_key <= 51 else 15,
                'name': config.names[reg_key],
                'midi': reg_key,
                'layers': layers,
            }
        elif args.debug:
            warn(f"out of Speedrum range: {reg_key} / {layers}")

    print(tpl_speedrum.render({
        'pads': pads,
        'debug': args.debug
        }))
