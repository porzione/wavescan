#!/usr/bin/env python
# -*- coding: utf-8 -*-

from argparse import ArgumentParser
import re
from pathlib import Path
from os import scandir
from os.path import dirname, realpath
from sys import stderr
import audiofile
from jinja2 import Template as J2, StrictUndefined as J2Undef
import config

aparser = ArgumentParser()
aparser.add_argument("-d", "--dir", dest="dir", required=True,
                     help="samples directory", metavar="DIR")
aparser.add_argument("--maxhh", dest="maxhh", required=False,
                     help="max closed HiHat duration 1-999 ms",
                     metavar="HH_LEN_MS")
aparser.add_argument("--channel", dest="channel", required=False,
                     help="MIDI channel 1-16 (LSP)", metavar="CHANNEL")
aparser.add_argument("--lsp",
                     action="store_true", dest="lsp", default=False,
                     help="LSP output")
aparser.add_argument("--sfz",
                     action="store_true", dest="sfz", default=False,
                     help="SFZ output")
aparser.add_argument("-D",
                     action="store_true", dest="debug", default=False,
                     help="debug output")
aparser.add_argument("--limit",
                     action="store_true", dest="limit", default=False,
                     help="respect LSP limits and skip extra data")
args = aparser.parse_args()
path = Path(args.dir)
if not path.exists():
    exit(f'{path} does not exist')
elif not path.is_dir():
    exit(f'{path} is not directory')

midi_channel = 0
if args.channel:
    if not args.channel.isnumeric():
        exit(f"channel '{args.channel}' not a number")
    midi_channel = int(args.channel)
    if not 1 <= midi_channel <= 16:
        exit(f"channel '{midi_channel}' is out of range")
    midi_channel -= 1

if args.lsp:
    spath = dirname(realpath(__file__))
    with open(f'{spath}/lsp-sampler-global.j2', 'r', encoding='ascii') as fin:
        src = fin.read()
    tpl_global = J2(src, undefined=J2Undef)
    with open(f'{spath}/lsp-sampler-region.j2', 'r', encoding='ascii') as fin:
        src = fin.read()
    tpl_region = J2(src, undefined=J2Undef)
    lsp = {}
elif args.sfz:
    spath = dirname(realpath(__file__))
    with open(f'{spath}/sfz.j2', 'r', encoding='ascii') as fin:
        src = fin.read()
    tpl_sfz = J2(src, undefined=J2Undef)
    sfz = {}

maxhh = 0
if args.maxhh:
    if not args.maxhh.isnumeric():
        exit(f"HH duration '{args.maxhh}' not a number")
    maxhh = int(args.maxhh)
    if not 1 <= maxhh <= 999:
        exit(f"HH duration '{maxhh}' is out of range")
    maxhh /= 1000


def warn(msg):
    """print message to stderr"""
    print(msg, file=stderr)


def scantree(pathname):
    """Recursively yield DirEntry objects for given directory."""
    for entry in scandir(pathname):
        if entry.is_dir(follow_symlinks=False):
            yield from scantree(entry.path)
        else:
            yield entry


def print_info(ent):
    """Print sample info"""
    print(f'{ent.path}\n'
          f'channels   : {audiofile.channels(ent.path)}\n'
          f'duration   : {audiofile.duration(ent.path):.8}\n'
          f'samples    : {audiofile.samples(ent.path)}\n'
          f'sample rate: {audiofile.sampling_rate(ent.path)}\n'
          f'bit depth  : {audiofile.bit_depth(ent.path)}\n')


def guess_note(ent, duration):
    """Tryng to guess instrument from pathname"""
    for rx in rx_instr:
        if rx[0].match(ent.path):
            num = rx[1]
            dur_msg = None
            if num == 1000:
                # closed: 42, open: 46
                if maxhh:
                    (num := 46) if duration > maxhh else (num := 42)
                    dur_msg = f"duration: {duration}, maxhh: {maxhh}"
                else:
                    # Answer to the Ultimate Question
                    num = 42
            if args.debug:
                human_name = f"{rx[0].pattern} {num} {config.names[num]}"
                msg = f"guess {ent.name} is {human_name}"
                if dur_msg:
                    msg = f"{msg} ({dur_msg})"
                warn(msg)
            return num
    return 0


# array of arrays [compiled_regex, note_number]
rx_instr = []
for rx in config.instruments:
    try:
        rx_instr.append([
            re.compile(f".*{rx[0]}.+", re.I),
            rx[1]
        ])
    except re.error as err:
        warn(f"problem with regex '{rx[0]}': {err}")


re_sample = re.compile(config.SAMPLE, re.I)
re_ignore = re.compile(config.IGNORE, re.I)
c_unparsed = 0
for ent in scantree(path):
    if re_sample.match(ent.name) and not re_ignore.match(ent.path):
        if args.lsp:
            # workaround for mono
            pan_l = '0.0' if audiofile.channels(ent.path) == 1 else '-100.0'
            duration = audiofile.duration(ent.path)
            if (midi_note := guess_note(ent, duration)) == 0:
                warn(f"can't guess: {ent.path}")
                c_unparsed += 1
                continue
            lsp[ent.path] = {
                'debug': args.debug,
                'name': ent.name,
                'lsp_note': midi_note % 12,
                'midi_note': midi_note,
                'midi_name': config.names[midi_note],
                'channels': audiofile.channels(ent.path),
                'duration': duration,
                'samples': audiofile.samples(ent.path),
                'sampling_rate': audiofile.sampling_rate(ent.path),
                'bit_depth': audiofile.bit_depth(ent.path),
                'chan': midi_channel,
                'oct': int(midi_note / 12),
                'pan_l': pan_l
            }
        elif args.sfz:
            duration = audiofile.duration(ent.path)
            if (midi_note := guess_note(ent, duration)) == 0:
                warn(f"can't guess instrument: {ent.path}")
                c_unparsed += 1
                continue
            if midi_note not in sfz:
                sfz[midi_note] = []
            sfz[midi_note].append({
                'pathname': ent.path,
                'channels': audiofile.channels(ent.path),
                'duration': duration,
                'samples': audiofile.samples(ent.path),
                'sampling_rate': audiofile.sampling_rate(ent.path),
                'bit_depth': audiofile.bit_depth(ent.path),
            })
        else:
            print_info(ent)

if args.lsp:
    if len(lsp) == 0:
        warn("nothing found")
        exit()

    print(tpl_global.render(inst=0))
    regions = []
    samples = {}
    c_skipped = 0
    c_samples = 0
    for pathname, data in sorted(lsp.items(), key=lambda x: x[1]['midi_note']):
        midi_note = data['midi_note']
        if midi_note not in regions:
            regions.append(midi_note)

        if midi_note not in samples:
            samples[midi_note] = 0

        if args.limit:
            if samples[midi_note] >= config.MAX_SAMPLES:
                warn(f"samples limit: {pathname} {data['midi_name']}")
                c_skipped += 1
                continue
            if len(regions) >= config.MAX_INSTRUMENTS:
                warn(f"instruments limit: {pathname} {data['midi_name']}")
                c_skipped += 1
                continue

        print(tpl_region.render(
            pathname=pathname,
            instr_num=regions.index(midi_note),
            sample_num=samples[midi_note],
            **data
        ))

        samples[midi_note] += 1
        c_samples += 1

    print(f"# skipped (limit): {c_skipped}\n"
          f"# unparsed: {c_unparsed}\n"
          f"# instruments: {len(regions)}\n"
          f"# samples: {c_samples}"
          )

elif args.sfz:
    if len(sfz) == 0:
        warn("nothing found")
        exit()

    regions = []
    c_samples = 0

    for reg_key, samples in sorted(sfz.items()):
        regions.append({
            'midi_note': reg_key,
            'midi_name': config.names[reg_key],
            'samples': samples
        })

        c_samples += len(samples)

    print(tpl_sfz.render({
        'regions': regions,
        'debug': args.debug
        }))

    if args.debug:
        print(f"// unparsed: {c_unparsed}\n"
              f"// regions: {len(sfz)}\n"
              f"// samples: {c_samples}"
              )
