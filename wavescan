#!/usr/bin/env python
# -*- coding: utf-8 -*-

from argparse import ArgumentParser
import re
from pathlib import Path
from os import scandir
from os.path import dirname, realpath
from sys import stderr
import audiofile
import hashlib
from jinja2 import Template as J2, StrictUndefined as J2Undef
import xml.etree.ElementTree as ET
# import pprint
import config

ENCODING = "utf-8"

aparser = ArgumentParser()
aparser.add_argument("-d", "--dir", dest="dir", required=True,
                     help="samples directory", metavar="DIR")
aparser.add_argument("--maxhh", dest="maxhh", required=False,
                     help="max closed HiHat duration 1-999 ms",
                     metavar="HH_LEN_MS")
aparser.add_argument("--channel", dest="channel", required=False,
                     help="MIDI channel 1-16 (LSP)", metavar="CHANNEL")
aparser.add_argument("--lsp",
                     action="store_true", dest="lsp", default=False,
                     help="LSP output")
aparser.add_argument("--limit",
                     action="store_true", dest="limit", default=False,
                     help="respect LSP limits and skip extra data")
aparser.add_argument("--sfz-mk",
                     action="store_true", dest="sfz_mk", default=False,
                     help="Add lokey/hikey/pitch instead of just key")
aparser.add_argument("--sfz",
                     action="store_true", dest="sfz", default=False,
                     help="SFZ output")
aparser.add_argument("--speedk",
                     action="store_true", dest="speedk", default=False,
                     help="Speedrum Lite output")
aparser.add_argument("--speedkit",
                     action="store_true", dest="speedkit", default=False,
                     help="Speedrum output")
aparser.add_argument("--no-remap",
                     action="store_true", dest="no_remap", default=False,
                     help="Disable remapping")
aparser.add_argument("--one-out",
                     action="store_true", dest="one_out", default=False,
                     help="One output for all Speedrum pads")
aparser.add_argument("-D",
                     action="store_true", dest="debug", default=False,
                     help="debug output")
args = aparser.parse_args()
path = Path(args.dir)
if not path.exists():
    exit(f'{path} does not exist')
elif not path.is_dir():
    exit(f'{path} is not directory')

midi_channel = 0
if args.channel:
    if not args.channel.isnumeric():
        exit(f"channel '{args.channel}' not a number")
    midi_channel = int(args.channel)-1
    if not 0 <= midi_channel <= 15:
        exit(f"channel '{args.channel}' is out of range")

s_path = dirname(realpath(__file__))
if args.lsp:
    with open(f'{s_path}/lsp-sampler.j2', 'r', encoding='ascii') as fin:
        src = fin.read()
    tpl_lsp = J2(src, undefined=J2Undef)
    lsp = {}
elif args.sfz:
    with open(f'{s_path}/sfz.j2', 'r', encoding='ascii') as fin:
        src = fin.read()
    tpl_sfz = J2(src, undefined=J2Undef)
    sfz = {}
elif args.speedk or args.speedkit:
    sdr_root = ET.Element("Speedrum")
    sdr_root.set("FileType", "DrumKit")
    sdr_root.append(ET.Comment('Generated by Wavescan'))
    sdr_pads = ET.SubElement(sdr_root, 'Pads')
    if args.speedk:
        sdr_root.set("version", "2")
        sdr_root.set("creator", "SpeedrumLite")
    else:
        sdr_root.set("version", "3")
        sdr_root.set("creator", "Speedrum")
    speedrum = {}

maxhh = 0
if args.maxhh:
    if not args.maxhh.isnumeric():
        exit(f"HH duration '{args.maxhh}' not a number")
    maxhh = int(args.maxhh)
    if not 1 <= maxhh <= 999:
        exit(f"HH duration '{maxhh}' is out of range")
    maxhh /= 1000


def warn(msg):
    """print message to stderr"""
    print(msg, file=stderr)


def scantree(pathname):
    """Recursively yield DirEntry objects for given directory."""
    for entry in scandir(pathname):
        if entry.is_dir(follow_symlinks=False):
            yield from scantree(entry.path)
        else:
            yield entry


def print_info(ent):
    """Print sample info"""
    print(f'{ent.path}\n'
          f'channels   : {audiofile.channels(ent.path)}\n'
          f'duration   : {audiofile.duration(ent.path):.8}\n'
          f'samples    : {audiofile.samples(ent.path)}\n'
          f'sample rate: {audiofile.sampling_rate(ent.path)}\n'
          f'bit depth  : {audiofile.bit_depth(ent.path)}\n')


def guess_note(ent, duration):
    """Tryng to guess instrument from pathname"""
    for rx in rx_instr:
        if rx[0].match(ent.path):
            num = rx[1]
            dur_msg = None
            if num == 1000:
                # closed: 42, open: 46
                if maxhh:
                    (num := 46) if duration > maxhh else (num := 42)
                    dur_msg = f"duration: {duration}, maxhh: {maxhh}"
                else:
                    # Answer to the Ultimate Question
                    num = 42
            if args.debug:
                human_name = f"{rx[0].pattern} {num} {config.names[num]}"
                msg = f"guess {ent.name} is {human_name}"
                if dur_msg:
                    msg = f"{msg} ({dur_msg})"
                warn(msg)
            return num
    return 0


def speedrum_checksum(fname):
    """md5 is speedrum's checksum"""
    hash_md5 = hashlib.md5()
    with open(fname, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hash_md5.update(chunk)
    return hash_md5.hexdigest()


# array of arrays [compiled_regex, note_number]
rx_instr = []
for rx in config.instruments:
    try:
        rx_instr.append([
            re.compile(f".*{rx[0]}.+", re.I),
            rx[1]
        ])
    except re.error as err:
        warn(f"problem with regex '{rx[0]}': {err}")


re_sample = re.compile(config.SAMPLE, re.I)
re_ignore = re.compile(config.IGNORE, re.I)
c_unparsed = 0
for ent in scantree(path):
    if re_sample.match(ent.name) and not re_ignore.match(ent.path):
        if args.lsp:
            # workaround for mono
            pan_l = '0.0' if audiofile.channels(ent.path) == 1 else '-100.0'
            duration = audiofile.duration(ent.path)
            if (midi_note := guess_note(ent, duration)) == 0:
                warn(f"can't guess: {ent.path}")
                c_unparsed += 1
                continue

            if args.limit:
                if (midi_note in lsp and
                   len(lsp[midi_note]) >= config.MAX_SAMPLES):
                    warn(f"samples limit: {midi_note} {ent.path}")
                    continue
                if len(lsp) >= config.MAX_INSTRUMENTS:
                    warn(f"instruments limit: {midi_note} {ent.path}")
                    continue

            if midi_note not in lsp:
                lsp[midi_note] = {
                    'i': {
                        'lsp_note': midi_note % 12,
                        'midi_note': midi_note,
                        'midi_name': config.names[midi_note],
                        'oct': int(midi_note / 12),
                    },
                    'l': []
                }

            lsp[midi_note]['l'].append({
                'pathname': ent.path,
                'channels': audiofile.channels(ent.path),
                'duration': duration,
                'samples': audiofile.samples(ent.path),
                'sampling_rate': audiofile.sampling_rate(ent.path),
                'bit_depth': audiofile.bit_depth(ent.path),
                'pan_l': pan_l,
            })
        elif args.sfz:
            duration = audiofile.duration(ent.path)
            if (midi_note := guess_note(ent, duration)) == 0:
                warn(f"can't guess instrument: {ent.path}")
                c_unparsed += 1
                continue
            if midi_note not in sfz:
                sfz[midi_note] = []
            sfz[midi_note].append({
                'pathname': ent.path,
                'channels': audiofile.channels(ent.path),
                'duration': duration,
                'samples': audiofile.samples(ent.path),
                'sampling_rate': audiofile.sampling_rate(ent.path),
                'bit_depth': audiofile.bit_depth(ent.path),
            })
        elif args.speedk or args.speedkit:
            duration = audiofile.duration(ent.path)
            if (midi_note := guess_note(ent, duration)) == 0:
                warn(f"can't guess instrument {ent.path}")
                c_unparsed += 1
                continue
            if midi_note not in speedrum:
                speedrum[midi_note] = []
            if args.speedk and len(speedrum[midi_note]) > 0:
                warn(f"excess Lite layer, skipping {midi_note} {ent.path}")
                continue
            if args.speedkit and len(speedrum[midi_note]) > 7:
                warn(f"already have 8 layers, skipping {midi_note} {ent.path}")
                continue
            d = {
                'pathname': ent.path,
                'channels': audiofile.channels(ent.path),
                'duration': duration,
                'samples': audiofile.samples(ent.path),
                'sampling_rate': audiofile.sampling_rate(ent.path),
                'bit_depth': audiofile.bit_depth(ent.path),
            }
            if args.speedkit:
                d['checksum'] = speedrum_checksum(ent.path)
            speedrum[midi_note].append(d)
        else:
            print_info(ent)
            exit()


def speedrum_remap():
    """remap exceess notes to unused pads 36-51/67"""
    bound = 52 if args.speedk else 68
    free = []
    for k in range(36, bound):
        if k not in speedrum:
            free.append(k)
    if len(free) == 0:
        return {}
    excess = []
    for k, v in speedrum.items():
        if k >= bound or k < 36:
            excess.append(k)
    if len(excess) == 0:
        return {}
    sr_map = {}
    for e in excess:
        if len(free) > 0:
            f = free.pop(0)
            sr_map[e] = f
    return sr_map


def speedrum_fmt_comment(data):
    return f"channels:{ld['channels']} " \
        f"duration:{ld['duration']} " \
        f"samples:{ld['samples']} " \
        f"sampling_rate:{ld['sampling_rate']}" \
        f"bit depth:{ld['bit_depth']}"


def order_lsp(key):
    if key[0] in config.ordering:
        return config.ordering.index(key[0])
    else:
        return key[0] + 1000


if args.lsp:
    if len(lsp) == 0:
        warn("nothing found")
        exit()

    print(tpl_lsp.render({
        'notes': sorted(lsp.items(), key=order_lsp),
        'midi_channel': midi_channel,
        'debug': args.debug,
    }))

elif args.sfz:
    if len(sfz) == 0:
        warn("nothing found")
        exit()

    regions = []
    c_samples = 0

    for reg_key, samples in sorted(sfz.items()):
        regions.append({
            'midi_note': reg_key,
            'midi_name': config.names[reg_key],
            'samples': samples
        })

        c_samples += len(samples)

    print(tpl_sfz.render({
        'multikey': args.sfz_mk,
        'regions': regions,
        'debug': args.debug
    }))

    if args.debug:
        print(f"// unparsed: {c_unparsed}\n"
              f"// regions: {len(sfz)}\n"
              f"// samples: {c_samples}"
              )

elif args.speedk:
    if len(speedrum) == 0:
        warn("nothing found")
        exit()

    pads = {k: [] for k in range(36, 52)}
    remap = {} if args.no_remap else speedrum_remap()
    for note, layers in sorted(speedrum.items()):
        r_note = note
        if note in remap:
            r_note = remap[note]
            if args.debug:
                warn(f"remap: {note} -> {r_note}")
        d = {
            'name': config.names[note],
            'layers': layers,
        }
        # 16 (36-51) pads in Lite
        if not args.one_out:
            if note in config.ordering:
                d['out'] = config.ordering.index(note)
            else:
                d['out'] = 0
        if 35 <= r_note <= 51:
            pads[r_note] = d
        elif args.debug:
            warn(f"out of Speedrum Lite range: {note} / {layers}")

    pad_num = 0
    for num, data in pads.items():
        pad = ET.SubElement(sdr_pads, 'Pad')
        pad.set("PadNum", str(pad_num))
        pad_num += 1
        if len(data) == 0:
            continue
        pad.set("PadName", data['name'])
        pad.set("IsCustomName", "1")
        if 'out' in data:
            pad.set("Output", f"{data['out']}.0")
        for ld in data['layers']:
            layer = ET.SubElement(pad, 'Layer')
            layer.set("SampleFileAbsolute", ld["pathname"])
            # Lite is one layered
            layer.set("LayerNum", "0")
            if args.debug:
                comment = speedrum_fmt_comment(ld)
                layer.append(ET.Comment(comment))

    tree = ET.ElementTree(sdr_root)

    print('<?xml version="1.0" encoding="UTF-8"?>')
    ET.indent(sdr_root, space="\t", level=0)
    print(ET.tostring(sdr_root, ENCODING).decode(ENCODING))

elif args.speedkit:
    if len(speedrum) == 0:
        warn("nothing found")
        exit()

    pads = {k: [] for k in range(36, 68)}
    remap = {} if args.no_remap else speedrum_remap()
    for note, layers in sorted(speedrum.items()):
        r_note = note
        if note in remap:
            r_note = remap[note]
            if args.debug:
                warn(f"remap: {note} -> {r_note}")
        d = {
            'name': config.names[note],
            'layers': layers,
        }
        # 32 (36-67) in full version
        if not args.one_out:
            if note in config.ordering:
                d['out'] = config.ordering.index(note)
            else:
                d['out'] = 0
        if 36 <= r_note <= 67:
            pads[r_note] = d
        elif args.debug:
            warn(f"out of Speedrum range: {note} / {layers}")

    for num, data in pads.items():
        pad = ET.SubElement(sdr_pads, 'Pad')
        if len(data) == 0:
            continue
        pad.set("PadName", data['name'])
        pad.set("IsCustomName", "1")
        pad.set("LayerIndex", "0")
        if 'out' in data:
            pad.set("Output", f"{data['out']}.0")
        lc = 0
        for ld in data['layers']:
            layer = ET.SubElement(pad, 'Layer')
            layer.set("SampleFileAbsolute", ld["pathname"])
            layer.set("Checksum", ld['checksum'])
            if lc > 0:
                layer.set("Volume", "0.0")
            if args.debug:
                comment = speedrum_fmt_comment(ld)
                layer.append(ET.Comment(comment))
            lc += 1

    tree = ET.ElementTree(sdr_root)

    print('<?xml version="1.0" encoding="UTF-8"?>')
    ET.indent(sdr_root, space="\t", level=0)
    print(ET.tostring(sdr_root, ENCODING).decode(ENCODING))
